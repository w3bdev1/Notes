= Basic Terms =
* Repository → collection of commits
* Index → Staging area
* Working tree → Filesystem associated with a repo
* Commit — snapshot of working tree at some point in time
* Branch → A commit set as parentage
* Tag → A commit that names a specific commit
* HEAD → What is currently checked out.
    - If a branch is checked out, it refers to the branch
    - If a commit is checked out, it refers to the commit
    - Check → `git cat-file -t HEAD`
    - Decode the HEAD alias into the commit it references → `git rev-parse HEAD`

= Blob =
* It reperesents file contents.
* It is uniquely identified by SHA1 hash id.
* Same contents shall always be represented by the same blob, no matter where it appears: across commits, across repositories — even across the whole Internet.
* Blob stores no metadata about the content.

_In Practice_
* Check hash id for a file → `git hash-object <filename>`
* Check whether a hash id corresponds to a blob or not → `git cat-file -t <unique initial digits of blob-hash-id>`
* Cat file from its hash id → `git cat-file blob <unique initial digits of blob-hash-id>`

_Note_
* `hash-object` can be checked even without initializing a git repo, as it says which hash id Git is *going to store* for that file.
* [✗] But in case of `cat-file` the blob needs to be committed.

_hash-object vs sha1sum_
* `git hash-object` and `sha1sum` do not give same value as git prepends the string "blob " followed by the file size and a NUL to the file's contents before hashing.
* Check
    - `printf hello > greeting`
    - `git hash-object greeting`
    - `printf "blob 5\0$(cat greeting)" | sha1sum`

= Trees =
* Blobs are featureless. They have no name, no structure.
* Git attaches blobs as leaf nodes within a tree.
* Every commit holds a single tree.
* A tree contains blobs (file) or other trees(directory).
* List tree contents → `git ls-tree <tree-id>`
    - `git ls-tree HEAD`
    - `git ls-tree master`
* Check underlying hash id of the tree held by a commit → `git cat-file commit HEAD`
* The object can be listed → `find .git/objects -type f`
    - It results like this `.git/objects/05/63f7....`
    - So we can check the hash type using `git cat-file -t 0563`

= Journey from from a File to a Part of a Branch =
* When a file is is added to index (staged, `git add <filename>`), a blob is created.
    - List staged blobs → `git ls-files --stage`
    - We can check the type → `git cat-file -t <id>`
    - At this moment the blob is referenced in `.git/index`
    - It is not part of any tree yet.
* Create a tree → `git write-tree`
    - The tree id can be confirmed by grepping from `find .git/objects/ -type f`
    - This takes all the content from index (staging) and put them in the new tree.
    - So the blob created is now part of this tree.
* Create a commit object by using this tree → `echo "<Commit message>" | git commit-tree <tree-id>`
    - It takes a tree’s hash id and makes a commit object to hold it.
    - To have a parent, the parent commit’s hash id has be specified explicitly using the -p option.
* Add commit as head of a branch (say master) → `echo <Full-Commit-Id> > .git/refs/heads/master` 
    - Since we are saving the commit id in the branch head, full id needs to be specified.
    - This command tells Git that the branch name “master” should now refer to our recent commit.
    - Much safer way → `git update-ref refs/heads/master <inital digits of commit id>` (Does not work ???)
    - If `refs/heads/master` is not set to point to the new commit, it would have been considered “unreachable”, since nothing currently refers to it nor is it the parent of a reachable commit. When this is the case, the commit object will at some point be removed from the repository, along with its tree and all its blobs. (This happens automatically by a command called gc, which you rarely need to use manually). 
    - By linking the commit to a name within refs/heads, as we did above, it becomes a reachable commit, which ensures that it’s kept around from now on.
* Associate our working tree with master branch (like checking out) → `git symbolic-ref HEAD refs/heads/master`
* File → Blob → Tree → Commit

= Types of Commits =
*Branch is a commit*
* Since a commit can have one or more parents, and those commits can have parents, this is what allows a single commit to be treated like a branch. 
* Branch or all top level, referenced commits can be examined using the branch command → `git branch -v`
    - It returns the commit hash.

*Tag*
- A tag-name alias is identical to a branch alias in terms of naming a commit. 
- The major difference between the two is that tag aliases never change, whereas branch aliases change each time a new commit is checked in to that branch.
- Besides tags can have their own descriptions, just like the commits they reference.

*Merge commit*
* If a commit has multiple parents, it’s a “merge commit” — since it merged multiple commits into one

*Others*
* SHA1 hash
* name^ → parent of any commit
* name^^ → parent of the parent of given commit
* name^n → If a commit has multiple parent (e.g., merge commit), it refers to n-th commit
* name~n → n-th generation ancestor of a commit. name~5 is same as name^^^^^
* name:path → Reference a certain file within a commit’s content tree → `git diff HEAD^1:Readme.md HEAD^2:Readme.md`
* name^{tree} → Reference just the tree held by a commit, rather than the commit itself.
* name1..name2 → Commit ranges → `git diff <older commit hash>..HEAD`
    - If either name1 or name2 is omitted, HEAD is used in its place.
    - Review changes in testing other branch → `git diff master..HEAD` or `git diff master..`
    - Review changes after fetch since last rebase or merge → `git diff HEAD..master` or `git diff ..master`
* name1...name1 → It refers to all the commits referenced by name1 or name2, but not by both, i.e., all the unique commits in both branches.
* --since="2 weeks ago" → Refers to all commits since a certain date.
* --until="1 week ago" → Refers to all commits before a certain date.
* --grep=pattern → Refers to all commits whose commit message matches the regular expression pattern.
* --committer=pattern → Refers to all commits whose committer matches the pattern.
* --author=pattern → Refers to all commits whose author matches the pattern.
* --no-merges → Refers to all commits in the range that have only one parent — that is, it ignores all merge commits.
* Log changes made to the current branch (branched from master), by author johndoe, within the last month, which contain the text 'foo'
    - `git log --author='johndoe' --since='1 month' --grep='foo' master..`

*Conclusion*
* All these are mere nomenclatures.
* Git has only blobs, trees and commits.
* The world is simply a collection of commit objects, each of which holds a tree that references other trees and blobs, which store your data.

= Branching, Merging and Rebase =
* Each commit references its parent(s), but not its children.
* Base commits: the commits that branch was born from

*Merge*
* To merge from testing to master → `git checkout master; git merge testing`
* It may require resolving any conflicts between the states.
* Although the new master now contains the changes from testing, it also includes a new commit to represent the merging of master with testing. This commit doesn’t add anything new, but represents the work done to bring testing and master together. In a sense it’s a “meta-commit”, because its contents are related to work done solely in the repository, and not to new work done in the working tree.

*Rebase*
* In case of rebase we transplant the master branch straight onto testing, effectively moving it forward in time.
* That’s why the command is called “rebase”, because it changes the base commit of the branch it’s run from.
* Change local master's base commit to upstream/master → `git checkout master; git fetch upstream; git rebase upstream/master`
    - So any change in local master will have clean PR.

*Conclusion*
* Since rebase is potentially changing every commit in the branch, use rebase for local use which does not have any of downstream consumers
* Else use merge.
* Merge is also useful when you’re ready to pull your local branch’s changes back into the main branch

---

= Add, Delete, Rename =
* `git add <filename>`
* `git rm <filename>`
* `git mv <old filename> <new filename>`

= Undo, Redo =
* Check changes since last commit → `git status`
* Check commit log → `git log`
* The first few characters of the commit hash are enough to specify the commit.

*Restore changes in a file since last commit*
* `git restore <file name>`

*Restore to a earlier commit permanently*
* `git reset --hard <commit hash>`
* It resets the head of the working tree to a particular commit and erase all changes currently in my working tree, whether they’ve been registered for a checkin or not.

*Restore to a earlier commit temporarily*
* Restore the whole repo → `git checkout <commit hash>`
* Restore specific file → `git checkout <commit hash> file1 file2`
* Other ways to checkout to previous commit
    - Via number → `git checkout master~5` → 5th last saved commit
    - Via starting of commit message → `git checkout :/"My First Com"`
* It is a detached HEAD state, i.e., do not point to any branch and so it only changes the working tree. Here we can do experimental changes.
* Now we have 2 options
    - Save the experimental changes to a new branch → `git switch c <new branch name>`
    - Switch back to actual position removing experimental changes → `git switch -` or `git checkout <existing branch name>`

*Revert back to previous commit*
* In this case repo reverts (undoes) a previous commit and set it as new commit. Hence previous commit history is retained, unlike `git reset`
* First check all the present commits are done (`git commit -a`) and then `git revert <commit hash>`.

= Regain deleted files =
*Preserving changes of other files*
* `git checkout <When file was present commit hash> file1 file2`

*Adding patch for diff between deletion commit and its previous commit*
* `git diff <Deletion commit hash> <Previous of the deletion commit hash> | git apply`
* Note, all other changes within the 2 commits will also be added.

*Revert back the deletion commit*
* `git revert <Deletion commit hash>`
* Note, all other changes happened during the deletion commit will also be reverted.

= What has been changed =
*Change since last commit*
* Change `git diff`

*Change since some time*
* Since 4 hours → `git diff "@{4 hours}`
* Since yesterday → `git diff "@{yesterday}"`
* Since 2 weeks → `git whatchanged --since="2 weeks ago"`
* Since an specific commit and 2nd last commit → `git diff <specific commit hash> master~2`

= Git Merge Conflict =
* Add, Commit and Try to push. If there is conflict push won't happen.
* Then pull the repo first. Git will try to merge the changes automatically.
* If there is a conflict, git will tell `CONFLICT: ...`
* So open those file and manually merge.
* Then git add and commit.
* Try to git push again.

= Ignore Files =
* To ignore for all users: Mention the file in `$GIT_DIR/.gitignore`
* To ignore for a specific user: Mention the file in `$GIT_DIR/info/exclude`
* In case the file was already tracked by git, but now you want to ignore → `git update-index --assume-unchanged <file>`

= Update or Sync forked repo with upstream =
* Add the upstream repo as another remote → `git remote add upstream <upstream-url>`
* Then fetch from upstream → `git fetch upstream`
* Rewrite your master with upstream/master → `git rebase upstream/master`

= Change Remote url =
* `git remote set-url <origin> <url>`

--- 
*Sources*
1. http://www-cs-students.stanford.edu/~blynn/gitmagic/ch02.html
2. https://jwiegley.github.io/git-from-the-bottom-up/
