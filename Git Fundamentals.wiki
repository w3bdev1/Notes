= Basic Terms =
* Repository → collection of commits
* Index → Staging area
* Working tree → Filesystem associated with a repo
* Commit — snapshot of working tree at some point in time
* Branch → A commit set as parentage
* Tag → A commit that names a specific commit
* HEAD → What is currently checked out.
    - If a branch is checked out, it refers to the branch
    - If a commit is checked out, it refers to the commit
    - Check → `git cat-file -t HEAD`
    - Decode the HEAD alias into the commit it references → `git rev-parse HEAD`

= Blob =
* It reperesents file contents.
* It is uniquely identified by SHA1 hash id.
* Same contents shall always be represented by the same blob, no matter where it appears: across commits, across repositories — even across the whole Internet.
* Blob stores no metadata about the content.

_In Practice_
* Check hash id for a file → `git hash-object <filename>`
* Check whether a hash id corresponds to a blob or not → `git cat-file -t <unique initial digits of blob-hash-id>`
* Cat file from its hash id → `git cat-file blob <unique initial digits of blob-hash-id>`

_Note_
* `hash-object` can be checked even without initializing a git repo, as it says which hash id Git is *going to store* for that file.
* [✗] But in case of `cat-file` the blob needs to be committed.

_hash-object vs sha1sum_
* `git hash-object` and `sha1sum` do not give same value as git prepends the string "blob " followed by the file size and a NUL to the file's contents before hashing.
* Check
    - `printf hello > greeting`
    - `git hash-object greeting`
    - `printf "blob 5\0$(cat greeting)" | sha1sum`

= Trees =
* Blobs are featureless. They have no name, no structure.
* Git attaches blobs as leaf nodes within a tree.
* Every commit holds a single tree.
* A tree contains blobs (file) or other trees(directory).
* List tree contents → `git ls-tree <tree-id>`
    - `git ls-tree HEAD`
    - `git ls-tree master`
* Check underlying hash id of the tree held by a commit → `git cat-file commit HEAD`
* The object can be listed → `find .git/objects -type f`
    - It results like this `.git/objects/05/63f7....`
    - So we can check the hash type using `git cat-file -t 0563`

= Journey from from a File to a Part of a Branch =
* When a file is is added to index (staged, `git add <filename>`), a blob is created.
    - List staged blobs → `git ls-files --stage`
    - We can check the type → `git cat-file -t <id>`
    - At this moment the blob is referenced in `.git/index`
    - It is not part of any tree yet.
* Create a tree → `git write-tree`
    - The tree id can be confirmed by grepping from `find .git/objects/ -type f`
    - This takes all the content from index (staging) and put them in the new tree.
    - So the blob created is now part of this tree.
* Create a commit object by using this tree → `echo "<Commit message>" | git commit-tree <tree-id>`
    - It takes a tree’s hash id and makes a commit object to hold it.
    - To have a parent, the parent commit’s hash id has be specified explicitly using the -p option.
* Add commit as head of a branch (say master) → `echo <Full-Commit-Id> > .git/refs/heads/master` 
    - Since we are saving the commit id in the branch head, full id needs to be specified.
    - This command tells Git that the branch name “master” should now refer to our recent commit.
    - Much safer way → `git update-ref refs/heads/master <inital digits of commit id>` (Does not work ???)
    - If `refs/heads/master` is not set to point to the new commit, it would have been considered “unreachable”, since nothing currently refers to it nor is it the parent of a reachable commit. When this is the case, the commit object will at some point be removed from the repository, along with its tree and all its blobs. (This happens automatically by a command called gc, which you rarely need to use manually). 
    - By linking the commit to a name within refs/heads, as we did above, it becomes a reachable commit, which ensures that it’s kept around from now on.
* Associate our working tree with master branch (like checking out) → `git symbolic-ref HEAD refs/heads/master`
* File → Blob → Tree → Commit

= Types of Commits =
*Branch is a commit*
* Since a commit can have one or more parents, and those commits can have parents, this is what allows a single commit to be treated like a branch. 
* Branch or all top level, referenced commits can be examined using the branch command → `git branch -v`
    - It returns the commit hash.

*Tag*
- A tag-name alias is identical to a branch alias in terms of naming a commit. 
- The major difference between the two is that tag aliases never change, whereas branch aliases change each time a new commit is checked in to that branch.
- Besides tags can have their own descriptions, just like the commits they reference.

*Merge commit*
* If a commit has multiple parents, it’s a “merge commit” — since it merged multiple commits into one

*Others*
* SHA1 hash
* name^ → parent of any commit
* name^^ → parent of the parent of given commit
* name^n → If a commit has multiple parent (e.g., merge commit), it refers to n-th commit
* name~n → n-th generation ancestor of a commit. name~5 is same as name^^^^^
* name:path → Reference a certain file within a commit’s content tree → `git diff HEAD^1:Readme.md HEAD^2:Readme.md`
* name^{tree} → Reference just the tree held by a commit, rather than the commit itself.
* name1..name2 → Commit ranges → `git diff <older commit hash>..HEAD`
    - If either name1 or name2 is omitted, HEAD is used in its place.
    - Review changes in testing other branch → `git diff master..HEAD` or `git diff master..`
    - Review changes after fetch since last rebase or merge → `git diff HEAD..master` or `git diff ..master`
* name1...name1 → It refers to all the commits referenced by name1 or name2, but not by both, i.e., all the unique commits in both branches.
* --since="2 weeks ago" → Refers to all commits since a certain date.
* --until="1 week ago" → Refers to all commits before a certain date.
* --grep=pattern → Refers to all commits whose commit message matches the regular expression pattern.
* --committer=pattern → Refers to all commits whose committer matches the pattern.
* --author=pattern → Refers to all commits whose author matches the pattern.
* --no-merges → Refers to all commits in the range that have only one parent — that is, it ignores all merge commits.
* Log changes made to the current branch (branched from master), by author johndoe, within the last month, which contain the text 'foo'
    - `git log --author='johndoe' --since='1 month' --grep='foo' master..`

*Conclusion*
* All these are mere nomenclatures.
* Git has only blobs, trees and commits.
* The world is simply a collection of commit objects, each of which holds a tree that references other trees and blobs, which store your data.

= Branching, Merging and Rebase =
* Each commit references its parent(s), but not its children.

*Branching*
* Base commits: the commits that branch was born from.
    A   B   C   D
〇← 〇← 〇← 〇← 〇
    ↑             
    〇← 〇← 〇← 〇
    W   X   Y   Z 
* Here A is the base commit for the branch Z
    
*Merge*
* To merge from testing to master → `git checkout master; git merge testing`
* It may require resolving any conflicts between the states.
* Although the new master now contains the changes from testing, it also includes a new commit to represent the merging of master with testing. This commit doesn’t add anything new, but represents the work done to bring testing and master together. In a sense it’s a “meta-commit”, because its contents are related to work done solely in the repository, and not to new work done in the working tree.

_Visualize_
* `git checkout Z` → Switch to Z branch
* `git merge D` → merge commits B, C and D into Z

    A   B   C   D
〇← 〇← 〇← 〇← 〇←.
    ↑               \
    〇← 〇← 〇← 〇← 〇   
    W   X   Y   Z   Z'(Z+D)

*Rebase*
* In case of rebase we transplant the master branch straight onto testing, effectively moving it forward in time.
* That’s why the command is called “rebase”, because it changes the base commit of the branch it’s run from.
* Change local master's base commit to upstream/master → `git checkout master; git fetch upstream; git rebase upstream/master`
    - So any change in local master will have clean PR.

_Visualize_
* `git checkout Z` → switch to the Z branch
* `git rebase D` → change Z’s base commit to point to D

    A   B   C   D
〇← 〇← 〇← 〇← 〇←.
                    \
                    〇← 〇← 〇← 〇
                    W'  X'  Y'  Z'

*Conclusion*
* Since rebase is potentially changing every commit in the branch, use rebase for local use which does not have any of downstream consumers
* Else use merge.
* Merge is also useful when you’re ready to pull your local branch’s changes back into the main branch

= Interactive rebasing =
* In the above example the rebasing automatically rewrote all the commits from W to Z in order to rebase the Z branch onto the D commit (i.e., the head commit of the D branch).
* Complete control over how this rewriting is done can be achieved by the -i option to rebase.

*Options during interactive rebase*
* `pick` → Default, same when -i was not given, i.e., commit in question should be applied to its (now rewritten) parent commit
* `squash` → A squashed commit will have its contents “folded” into the contents of the commit preceding it. Clearly to squash all the commits, the first one has to be pick.
* `edit` →
* `(drop)` → Removing a commit from the interactive rebase file, or if you comment it out, the commit will simply disappear as if it had never been checked in. This can cause merge conflicts if any of the later commits in the branch depended on those changes.

*Advantages*
* Collapse multiple commits into single ones.
* Re-order commits.
* Remove incorrect changes.
* Move the base of current branch onto any other commit in the repository.
* Modify a single commit, to amend a change long after the fact.

= Index =
* It refers to the set of newly created trees and blobs which you created by running git add.
* The index is really just a staging area for next commit.
* It gives the ability to build up commits in stages.
* The state of the index becomes tree of the next commit.
* To ignore the index almost entirely pass the -a flag to commit.
* To commit only a hunk → `git add --patch <filename>`. It gives many options,
    - `y` → stage this hunk for the next commit
    - `n` → do not stage this hunk for the next commit
    - `q` → quit; do not stage this hunk or any of the remaining hunks
    - `a` → stage this hunk and all later hunks in the file
    - `d` → do not stage this hunk or any of the later hunks in the file
    - `g` → select a hunk to go to
    - `/` → search for a hunk matching the given regex
    - `j` → leave this hunk undecided, see next undecided hunk
    - `J` → leave this hunk undecided, see next hunk
    - `k` → leave this hunk undecided, see previous undecided hunk
    - `K` → leave this hunk undecided, see previous hunk
    - `s` → split the current hunk into smaller hunks
    - `e` → manually edit the current hunk 

*Try combination of different changes before commit*
* First commit differently for different combinations using `git add -i` or `git add --patch`
* Let there was 2 commits.
* Then from git log check the hash id of those two commits.
* Now create a temporary branch at the first commit → `git checkout -b temp <hash id of first commit>`
* Then cherry pick from second commit → `git cherry-pick <hash id of second commit>`
    - `cherry-pick` allows to apply specific commit ids
* Now run the tests.
* Now go back to master branch and delete the temporary branch → `git checkout master; git branch -D temp`
* Then add the commits that passed the tests to the main commit.

= Reset =
* Basically, reset is a reference editor, an index editor, and a working tree editor.

*Mixed Reset*
* The `--mixed` option, which is default, hence no option.
* It reverst `HEAD` and Index to a given commit.
* With `--soft` option, which is also default, only HEAD reverts, index is not touched.
* So `git reset <commit-hash>` reverts the HEAD to that commit and the changes after it goes to index.

*Soft Reset*
* Simply changing your HEAD reference to a different commit. 
* It can give a chance to create a new commit in place of the old one. 
    - In fact, if the commit you want to change is the most recent one checked in, you can use `commit --amend` to add your latest changes to the last commit as if you’d done them together.
* If there is downstream consumers, and they’ve done work on top of your previous head — the one you threw away — changing HEAD like this will force a merge to happen automatically after their next pull.
* Backup HEAD to its parent, i.e., effectively ignoring the last commit → `git reset --soft HEAD^`
    - Same can be achieved by `git update-ref HEAD HEAD^`

*Hard Reset*
* It changes branch as well as the working tree. Destructive.
* Hard reset against your current HEAD, it will erase all changes in your working tree.
* Hard reset against an earlier commit, it’s the same as first doing a soft reset and then using reset --hard to reset your working tree.
    - `git reset --hard HEAD~3` and `git reset --soft HEAD~3; git reset --hard` are same.

_Always stash before hard reset_
* First stash → `git stash`
* Then go back hard → `git reset --hard HEAD~3`
* Now if it was a mistake, restore the previous state by reset --hard with the reflog → `git reset --hard HEAD@{1}` ← restore from reflog before the change.
* Bring back the working tree changes → `git stash apply`

_A safer way than hard reset_
* Stash the changes → `git stash` ← stash is not branch specific
* Create a new branch from the older / target commit → `git checkout -b new-branch HEAD~3`
* Then do the changes in the new branch.
* If you want the new-branch to be the new master
    - Delete the master branch → `git branch -D master` ← still in reflog
    - Make new branch the master → `git branch -m new-branch master`

= Reflog and Stashing =
* These are other ways a blob can dwell in your repository.

*Reflog*
* A kind of meta-repository that records every change you make to your repository
* It records in the form of commits. 
* This means that when you create a tree from your index and store it under a commit (all of which is done by commit), you are also inadvertently adding that commit to the reflog.
* It can be viewed using → `git reflog`
* Reflogs persists independently of other changes in your repository for 30 days.

*Stash*
* `git stash` takes all your directory’s contents, including both working tree, and the state of the index, and creates blobs for them in the git repository, a tree to hold those blobs, and a pair of stash commits to hold the working tree and index and record the time when you did the stash.
* We can pull changes back out of the stash with `git stash apply`
* As stashed working tree is stored under a commit, we can work with it like any other branch.
    - `git log stash{2}`
    - `git show stash{2}`
    - `git checkout -b temp stash{2}`
* Clean up stash list
    - Use → `git reflog expire --expire=30.days refs/stash`
    - Don't use → `git stash clear`

---

= Add, Delete, Rename =
* `git add <filename>`
* `git rm <filename>`
* `git mv <old filename> <new filename>`

= Undo, Redo =
* Check changes since last commit → `git status`
* Check commit log → `git log`
* The first few characters of the commit hash are enough to specify the commit.

*Restore changes in a file since last commit*
* `git restore <file name>`

*Restore to a earlier commit permanently*
* `git reset --hard <commit hash>`
* It resets the head of the working tree to a particular commit and erase all changes currently in my working tree, whether they’ve been registered for a checkin or not.

*Restore to a earlier commit temporarily*
* Restore the whole repo → `git checkout <commit hash>`
* Restore specific file → `git checkout <commit hash> file1 file2`
* Other ways to checkout to previous commit
    - Via number → `git checkout master~5` → 5th last saved commit
    - Via starting of commit message → `git checkout :/"My First Com"`
* It is a detached HEAD state, i.e., do not point to any branch and so it only changes the working tree. Here we can do experimental changes.
* Now we have 2 options
    - Save the experimental changes to a new branch → `git switch c <new branch name>`
    - Switch back to actual position removing experimental changes → `git switch -` or `git checkout <existing branch name>`

*Revert back to previous commit*
* In this case repo reverts (undoes) a previous commit and set it as new commit. Hence previous commit history is retained, unlike `git reset`
* First check all the present commits are done (`git commit -a`) and then `git revert <commit hash>`.

= Regain deleted files =
*Preserving changes of other files*
* `git checkout <When file was present commit hash> file1 file2`

*Adding patch for diff between deletion commit and its previous commit*
* `git diff <Deletion commit hash> <Previous of the deletion commit hash> | git apply`
* Note, all other changes within the 2 commits will also be added.

*Revert back the deletion commit*
* `git revert <Deletion commit hash>`
* Note, all other changes happened during the deletion commit will also be reverted.

= What has been changed =
*Change since last commit*
* Change `git diff`

*Change since some time*
* Since 4 hours → `git diff "@{4 hours}`
* Since yesterday → `git diff "@{yesterday}"`
* Since 2 weeks → `git whatchanged --since="2 weeks ago"`
* Since an specific commit and 2nd last commit → `git diff <specific commit hash> master~2`

= Git Merge Conflict =
* Add, Commit and Try to push. If there is conflict push won't happen.
* Then pull the repo first. Git will try to merge the changes automatically.
* If there is a conflict, git will tell `CONFLICT: ...`
* So open those file and manually merge.
* Then git add and commit.
* Try to git push again.

= Ignore Files =
* To ignore for all users: Mention the file in `$GIT_DIR/.gitignore`
* To ignore for a specific user: Mention the file in `$GIT_DIR/info/exclude`
* In case the file was already tracked by git, but now you want to ignore → `git update-index --assume-unchanged <file>`

= Update or Sync forked repo with upstream =
* Add the upstream repo as another remote → `git remote add upstream <upstream-url>`
* Then fetch from upstream → `git fetch upstream`
* Rewrite your master with upstream/master → `git rebase upstream/master`

= Change Remote url =
* `git remote set-url <origin> <url>`

--- 
*Sources*
1. http://www-cs-students.stanford.edu/~blynn/gitmagic/ch02.html
2. https://jwiegley.github.io/git-from-the-bottom-up/
