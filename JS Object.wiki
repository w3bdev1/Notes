= Definition  =
* The JavaScript object is a collection of key-value pairs, similar to a map, dictionary, or hash-table in other programming languages. 
* Anything that is not a JS primitive is an Object.

= Anatomy of an Object =
* An Object is a collection of properties.
* A Property is a key-value pair that contains a name and a value.
* A Property Name is a unique value that can be coerced to a string that points to a value.
* A Property Value can be any value, including other objects or functions, that associated with the name/key.

{{{
    const objectName = {
        key / propertyName: propertyValue
    }
}}}

= Creation of an Empty Object =
*Object Literal*
* `const dog = {}`

*Using Constructor*
* `const cat = new Object()`

*Using Static Method*
* `const horse = Object.create({})`
* Static methids are rarely used for creation of empty objects.
* They are mostly used for inheriting properties of an existing object, i.e., prototyping.
    {{{
        const parents = {
            dna: 3.14159 
        }
        
        const child = Object.create(parents)
        
        console.log(child)  // {}
        console.log(child.dna)  // 3.14159
        
        console.log(
            Object.getPrototypeOf(child)
        )
    }}}

= Manipulating Properties on an Object =
*Set Property in Object Literal*
* `const cat = {name: 'meow'}`

_ES6 Shorthand_
* If property name and property value is same,

{{{
    let hello;
    let world;

    // Old way
    const obj = {
        hello: hello,
        world: world
    }

    // Modern way
    const obj = {
        hello,
        world,
    }
}}}

*Set and Get Using Property Accessors*
* Property accessors provide access to an object's properties by using the dot notation or the bracket notation.

_Bracket Notation_ → object['property']
* `dog['Number of Legs'] = 5`
* `console.log(dog['Number of Legs'])`

_Dot Notation_ → object.property
* `dog.name = 'doggy'`
* `console.log(dog.name)`
* Note that in case of dot notation only access names that follow variable name identifier conventions, i.e without spaces or that do not start with a digit, are valid.

*Object.defineProperty*
_Set Property_
* Syntax → Object.defineProperty(objectName, propertyNameInQuotes, {value: propertyValue})
* `Object.defineProperty(dog, 'breed', { value: 'Bull Dog' })`

_Set Getter_
* Object.defineProperty(dog, 'doBark', { get: () => 'Bhow! Bhow!...' })
* Object.defineProperty(dog, 'getBreedName', { get: function() { return this.breed } })

*Computed Property*
* Using a variable or expression as a property name by wrapping it in square brackets is called a computed property.
{{{
    const vinf = 'veryInterestingNameOfMine'
    
    const me = {
        [vinf]: 'John Doe'
    }
}}}

*Delete Property*
* Object properties can be removed with the delete keyword.
* `delete dog.name`

= Object Methods =
*Method*
* When a function is assigned to an object, it is called a method.
* It can be written in shorthand without the `function` keyword.
    {{{
        const obj = {
          hello() {
              console.log('yo')
          }
        }
        
        obj.hello()
    }}}

*this in Method*
_In normal function_
* In a normal method, `this` refers to the object on which it is defined.

    {{{
        const obj = {
          username: 'Suckless',
          hello() {
            console.log(`My name is ${this.username}`)
          }
        }

        obj.hello(); // My name is Suckless 
    }}}

_In arrow function_
* Functions using the arrow syntax are not bound to `this`, so it refers to the outer or global this context.

    {{{
        const obj = {
          username: 'Suckless',
          hello: () => console.log(this.username)
        }

        obj.hello(); // My name is undefined
    }}}

*Method Chaining*
* In certain JS libraries you will see method chaining with `obj.doThis().toThat()`, which is made possible by simply returning the value of this from each method.

{{{
    const game = {
        health: 100,

        log() {
        console.log(`Health: ${this.health}`);
        },

        takeDamage() {
        this.health -= 10;
        this.log();
        return this; // Required for chaining
        },

        heal() {
        this.health += 10;
        this.log();
        return this; // Required for chaining
        },
    }
    
    game.takeDamage().takeDamage().takeDamage().heal()
}}}

= Constructors =
* Constructors are just functions that describe how to create an Object.
* By convention forst character of constructor name is capitalized.

{{{
    function Boat(name) {
      this.name = name;
      this.created = Date.now()
    }
}}}

* The object is then instantiated with the `new` keyword.
{{{
    const sally = new Boat('Sally');
    const molly = new Boat('Molly');
    
    console.log( sally.created )
}}}

* In modern JS, there is syntactic sugar named `Class` in place of constructor function, although under the hood it works as same.

= Reference =
*Default Behaviour*
* An object is stored in the heap memory, which means variables maintain a reference to it, as opposed to a full copy of it. 
* When checking for object equality, it checks the reference - not the actual value of properties.
    {{{
        const original = { }

        const x = original;
        const y = original;

        x === y; // true
        x === {}; // false
    }}}
* Any variable that points to that reference can set its properties and they will be shared between all variables.
    {{{
        x.hello = 'world';

        original.hello; // world
        y.hello; // world
    }}}

*Create Separate Reference*
* As we have seen objects pointing to same object share there properties.
* Therefore to safely use values of an object is to create a separate reference or clone or copy of it.

_Using object.assign_
* `Object.assign` allows us to copy multiplr objects' properties and create a new reference → `Object.assign({}, objectName1, objectName2, ...)`
- Its properties will be copied to the new object, thus changes to the original object will not affect the clone.

{{{
    const original = {
        hello: 'world'
     }

    const clone = Object.assign({ }, original);

    clone === original; // false

    original.hello = 'changed!';

    clone.hello; // world (did not change)
}}}

* Note that it only copies internal properties owned by the object itself, not inherited property. 
* Check the owned property names of an object → `Object.getOwnPropertyNames(objectName)`
* If multiple object referenced have any same property name, the last one will replace the earlier one.

_Using Spread Syntax_
* Syntax → `let newObj = { ...oldObject1, ...oldObject2, me: 'Someone' }`

= Destructure an Object =
_Destructure with property name as variable name_
{{{
    const spider = {
        name: 'spidy',
        legs: 8
    }
    
    // Old days
    const spiderLegs = spider.legs
    const spiderName = spider.name
    
    // Modern syntax
    const { legs, name } = spider
    console.log(name, legs)
}}}
* Sequence does not matter.

_Destructure with custom variable name_
* `const {name: spiderName, legs: spiderLegs} = spider`

= Loop over an Object =
*For...in loop*
* It loops over all enumerable properties as well as prototypes.
* `for (k in objectName) { console.log(k) }`

*For...of loop*
* Loop over keys → `for (k of Object.keys(objectName)) { console.log(k) }`
* Loop over values → `for (v of Object.values(objectName)) { console.log(v) }`

*Better way : Loop over (key, value) tuple*
* Syntax → `for (const [k,v] of Object.entries(objectName)) { console.log(k, v) }`
