= Definition =
* A function is piece of code that can be called during the lifecycle of the app to perform a task or return a value.

= Anatomy of a Function =
*During function declaration / definition / statement*
* It starts with a `function` keyword.
* A function declaration can be broken down into the following pieces.
    1 Name
    2 Parameters : A list of inputs that can be passed into a function.
    3 Body : The logic or statements that perform the computation.
    {{{
        function functionName(parameter1, parameter2) {
            return parameter1 + parameter2  // body
        }
    }}}
    
*During function call*
* A function declaration on its own does not do anything. We make use of functions by calling them with proper arguments. 
* The return value of the function can be assigned to a variable.
* If a function body does not contain a `return` statement, it implicitly returns `undefined`.
* `const returnValue = functionName(argument1, argument2)`

*Parameter vs Argument*
* Parameters are the variable inputs used in function declaration or definition.
* Arguments are actual values or expressions used when calling a function.

= Function Declarations vs Expressions =
*Function Declaration*
* A function declaration is a statement that describe what the code does.
* Declarations are hoisted at the top of the scope before any other code runs.

*Function Expression*
* In this case we use a function as a value or expression by assigning an anonymous function to a variable or parameter.
    {{{
        const makeBeer1 = function(qty) {
            return 'ðŸº'.repeat(qty);
        }
    }}}
* While not common, it is possible to also assign a name to a function expression.
    {{{
        const makeBeer = function beerFun(qty) {
            return 'ðŸº'.repeat(qty);
        }
    }}}
* Function expression is not hoisted.

_Benefits of Function Expression_
* ability to be reassigned
* flexibility when composing higher order functions
* they donâ€™t pollute the global scope

_IIFE (Immediately Invoked Function Expression)_
* It is wrapping an anonymous function in parenthesis, and immediately calling it by adding parenthesis afterwards
{{{
    (function () {
        return 5;
    })()
}}}

= Structuring Parameters =
*Positional*
* In this case when calling the function, the arguments have to be in correct order.
    {{{
        function topThree (first, second, third) {
            return `Top 3 persons are ${first}, ${second}, ${third}`
        }
        
        const toppers = topThree('John', 'Jane', 'June')
    }}}
* It becomes error prone as number of parameters increase.

*Named*
* Function have one parameter which is an object and hence can be destrctured.
    {{{
        function topThree (topStudents) {
            const { first, second, third } = topStudents
            return `Top 3 persons are ${first}, ${second}, ${third}`
        }
        
        const toppers = topThree({first: 'John', second: 'Jane', third: 'June'})
    }}}
* So we donâ€™t need to worry about the order of arguments
* It also makes code flexible.

*Rest*
* We can spread the parameter object, so that we can call the function with multiple positioned arguments and access them as array inside the function body.
    {{{
        function AIR(top, ...args) {
            return `AIR1 is ${top} and other toppers are ${args.join(', ')}.`
        }
        
        const toppers = AIR('John Doe', 'Jane', 'June')
    }}}
    
= Closure =
* In simpler terms, it is a function within a function, where the outer functionâ€™s local variables remain available in memory after creation and popped off from call stack.
* Therefore the inner function has access to the state of outer function when it was created.

{{{
    function outer(){
        let count = 0;
        
        function inner(){
            count++;
            return `${count}`
        }
        
        return inner
    }
    
    const fun = outer(); // const fun = inner(){ count++; return `${count}`}
    
    console.log(fun())   // 1
    console.log(fun())   // 2
    console.log(fun())   // 3
    console.log(fun())   // 4
}}}

= Arrow Functions =
* Arrow functions provide syntatic sugar for writing compact function expression.

{{{
    const functionName = (parameters) => {
        // function body
    }
}}}

_Features_
* Does not have its own `this` object.
* Implicit return value when brackets are omitted. â†’ `const sum = (a, b) => a + b`
* Always an expression, never a statement.

= Pure Functions =
* A pure function is one that only relies only its inputs, produces no side effects, and does not modify values outside its local scope.
* Example of an impure function,
    {{{
        let global = 0;
        const impure = () => {
            global++;
            return global ** 2;
        }

        const pure = (x) => x ** 2;
    }}}

= Higher Order Functions =
* A higher order function is created by combining (or composing) multiple functions together by 
    1. Functions as argument of a function or 
    2. Function returning other function

*Functions as argument*
* For example, `setTimeout` function allows to execute a code after certain delay. It achieves it by taking a function as its first argument and the delay (in milliseconds) as second argument.
    {{{
        let wait = () => console.log('Waiting period finished!')
        setTimeout( wait, 2000 )
    }}}
* Higher order array methods, e.g., map, filter, etc also takes function as an argument.
    {{{
        const nums = [1,2,3,4]
        squaredNums = nums.map(n => n**2)
    }}}

*Function returning function*
* Recall closures.
* In short, inner function can remember local variables of outer function, but outer function cannot look into inner function's lexical environment.
    {{{
        const a = 1
        
        const outer = () => {
            
            const b = 2
            
            const inner = () => {
                const c = 3
                return a + b + c
            }
            
            console.log(a, b, c) // c is not defined
        }
    }}}
* Lets simulate a react hook
    {{{
        function useCat() {
            let name = 'baby kitten'
            
            return [
                () => `Meow..., from ${name}`,
                (newName) => name = Newname
            ]
        }
        
        const [ meow, setName ] = useCat()
        console.log(meow())
        setName('Tom')
        console.log(meow())
    }}}
    - N.B. inner functions in the returning array has access to local variables of outer useCat function.

= Recursion =
* A recursive function is one that calls itself from inside its own function body. 
* If a terminating condition is not provided it will create and infinite loop.
* Example of a tree traversal of file system in current directory,
    {{{
        const fs = require('fs');
        const { join } = require('path');

        const traverse = (dir) => {

            const subfolders = fs.statSync(dir).isDirectory() 
                               && fs.readdirSync(dir);

            if (subfolders) {

                console.log('ðŸ‘ŸðŸ‘ŸðŸ‘Ÿ Traversing ', dir);

                subfolders.forEach(path => {
                    const fullPath = join(dir, path);

                    traverse( fullPath );   // Recursion
                });
            }
        }
        traverse( process.cwd() );

    }}}

